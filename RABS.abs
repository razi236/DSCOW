module ABS.ResourceManager;
import * from ABS.StdLib;
export *;
data Quality = Efficiency(Int) | Pathologist | BioTechnician | ProcessingMachine | EmbeddingMachine | StainingMachine | Receptionist | VanDriver | DeliveryVan | HeadWaiter | RunnerWaiter | Cook | CookAssistant;

// Resource Management
// Translation fetches resources from the database and store them in a resource map in the ABS program.
// The following code helps to add, acquire and release the resources.

data Availability = Free | Busy;

interface ResourceManager {
    List<Int> addRes(List<Set<Quality>> newResources);
    List<Int> holdRes(List<Set<Quality>> wantedResources);
    Unit releaseRes(List<Int> ids);
    Unit print();
}

class ResourceManager implements ResourceManager {
    Map<Int, Pair<Availability, Set<Quality>>> resources = map[];
    Int resource_counter = 0;

    Unit print() {
        println(toString(resources));
    }
    List<Int> addRes(List<Set<Quality>> newResources) {
        List<Int> result = list[];
        foreach (r in newResources) {
            resource_counter = resource_counter + 1;
            resources = insert(resources, Pair(resource_counter, Pair(Free, r)));
            result = Cons(resource_counter, result);
        }
        //println(toString(resources));
        return result;
    }

    List<Int> holdRes(List<Set<Quality>> wantedResources) {
        List<Int> result = list[];
        Map<Int, Pair<Availability, Set<Quality>>> lr = this.resources;
        while (result == Nil) {
            foreach (q in wantedResources) {
                Bool found = False;
                foreach (entry in entries(lr)) {
                    if (!found
                        && fst(snd(entry)) == Free
                        && isSubset(q, snd(snd(entry))))
                    {
                        found = True;
                        result = Cons(fst(entry), result);
                        lr = put(lr, fst(entry), Pair(Busy, snd(snd(entry))));
                    }
                }
            }
            if (length(result) != length(wantedResources)) {
                // we did not find all needed resources
                println(`hold retrying: Resources = $this.resources$ We want $wantedResources$`);
                result = Nil;
                lr = this.resources;
                await this.resources != lr;
                lr = this.resources;
            } else {
                // we're happy
                /*
                println("***********************************************");
                println("We have acquired all the requested resources :)");
                println("***********************************************");
                */
                this.resources = lr;
            }
        }

        //println(toString(this.resources));
        return result;
    }

    Unit releaseRes(List<Int> ids) {
        Set<Int> all_ids = keys(resources);
        foreach (id in ids) {
            if (contains(all_ids, id)) {
                Pair<Availability, Set<Quality>> entry = lookupUnsafe(resources, id);
                resources = put(resources, id, Pair(Free, snd(entry)));
            }
        }
        /*
        println("***********************************************");
        println("We have released all the acquired resources :)");
        println("***********************************************");
        */

        //println(toString(this.resources));
    }
}

// ABS does not support disjunction between future return tests (await f1? || await f2?)
// The following code is a syntactic sugar for the disjunction between the return tests.
// The code is not generic, supports only futures of integer type (Fut<Int>).

interface AwaitFut
{
    Unit awaitFut(List<Fut<Int>> fut);
    Bool checkFut();
}
class AwaitFut implements AwaitFut
{
    Bool resolved = False;
    Unit awaitFut(List<Fut<Int>> fut)
    {
        try {
            if(!isEmpty(fut)){
               foreach(f in fut)
               {
                   await f?;
               }
               resolved = True;
               println("Future Resolved:)");
            }
        } catch {
            NullPointerException  => println(`Future is not initialized`);
        }
    }
    Bool checkFut()
    {
        return resolved;
    }
}
module Pathology;
import * from ABS.ResourceManager;

import * from ABS.StdLib;

interface Pathology {
  Int registerCase(ResourceManager rm,Grossing g, Processing pr, Embedding em, Sectioning sc, Staining st, MicroscopicAnalysis ma);}

class Pathology implements Pathology {
  List<Triple<Int, Int, String>> processingTray = list(Nil);
  Int caseNum = 1;
  Int registerCase(ResourceManager rm,Grossing g, Processing pr, Embedding em, Sectioning sc, Staining st, MicroscopicAnalysis ma){
    Pair<Int, String> newSpecimen = Pair( this.caseNum, ( "Test" + toString(this.caseNum) ) );Fut<Int> f;[Deadline: Duration(110)]    f = g!gross(rm,pr, em, sc, st, ma, newSpecimen);println(( ( ( "Time: " + toString(now()) ) + ( " : case " + toString(this.caseNum) ) ) + "" ));this.caseNum = ( this.caseNum + 1 );await f?;try {
    Duration d = deadline();
    Rat r = durationValue(d);
    assert r > 0;
    } catch {
    AssertionFailException => println(`The method "registerCase" have missed the deadline.`);
    }
    return 0;
  }
  }

interface Grossing {
  Int gross(ResourceManager rm,Processing pr, Embedding em, Sectioning sc, Staining st, MicroscopicAnalysis ma, Pair<Int, String> x);}

class Grossing implements Grossing {
  List<Triple<Int, Int, String>> processingTray = list(Nil);
  Int gross(ResourceManager rm,Processing pr, Embedding em, Sectioning sc, Staining st, MicroscopicAnalysis ma, Pair<Int, String> x){
    Int i = 1;List<Int> rid = list(Nil);rid = await rm!holdRes(list[set[BioTechnician, Efficiency( 2 )]]);duration(5, 5);List<Fut<Int>> futList = list(Nil);while (( i <= 3 )) {
      Triple<Int, Int, String> block = Triple( fst(x), i, snd(x) );
      if ( ( length(this.processingTray) < 3 ) ){
        this.processingTray = appendright(this.processingTray, block);
      }
      if ( ( length(this.processingTray) == 3 ) ){
        Fut<Int> f;
        [Deadline: Duration(100)]        f = pr!process(rm,em, sc, st, ma, this.processingTray);
        futList = appendright(futList, f);
        this.processingTray = Nil;
      }
      i = ( i + 1 );
    }await rm!releaseRes(rid);while (! isEmpty(futList)) {
      Fut<Int> f = head(futList);
      futList = tail(futList);
      await f?;
    }try {
    Duration d = deadline();
    Rat r = durationValue(d);
    assert r > 0;
    } catch {
    AssertionFailException => println(`The method "gross" have missed the deadline.`);
    }
    return 0;
  }
  }

interface Processing {
  Int process(ResourceManager rm,Embedding em, Sectioning sc, Staining st, MicroscopicAnalysis ma, List<Triple<Int, Int, String>> processingTray);}

class Processing implements Processing {
  List<Triple<Int, Int, String>> blockTray = list(Nil);
  Int process(ResourceManager rm,Embedding em, Sectioning sc, Staining st, MicroscopicAnalysis ma, List<Triple<Int, Int, String>> processingTray){
    List<Int> rid = list(Nil);rid = await rm!holdRes(list[set[ProcessingMachine, Efficiency( 10 )]]);duration(5, 5);this.blockTray = concatenate(this.blockTray, processingTray);await rm!releaseRes(rid);List<Fut<Int>> futList = list(Nil);while (! isEmpty(this.blockTray)) {
      Fut<Int> f;
      [Deadline: Duration(100)]      f = em!embed(rm,sc, st, ma, head(this.blockTray));
      futList = appendright(futList, f);
      this.blockTray = tail(this.blockTray);
    }while (! isEmpty(futList)) {
      Fut<Int> f = head(futList);
      futList = tail(futList);
      await f?;
    }try {
    Duration d = deadline();
    Rat r = durationValue(d);
    assert r > 0;
    } catch {
    AssertionFailException => println(`The method "process" have missed the deadline.`);
    }
    return 0;
  }
  }

interface Embedding {
  Int embed(ResourceManager rm,Sectioning sc, Staining st, MicroscopicAnalysis ma, Triple<Int, Int, String> block);}

class Embedding implements Embedding {
  
  Int embed(ResourceManager rm,Sectioning sc, Staining st, MicroscopicAnalysis ma, Triple<Int, Int, String> block){
    List<Int> rid = list(Nil);rid = await rm!holdRes(list[set[BioTechnician, Efficiency( 2 )]]);duration(5, 5);await rm!releaseRes(rid);Fut<Int> f;[Deadline: Duration(100)]    f = sc!section(rm,st, ma, block);await f?;try {
    Duration d = deadline();
    Rat r = durationValue(d);
    assert r > 0;
    } catch {
    AssertionFailException => println(`The method "embed" have missed the deadline.`);
    }
    return 0;
  }
  }

interface Sectioning {
  Int section(ResourceManager rm,Staining st, MicroscopicAnalysis ma, Triple<Int, Int, String> block);}

class Sectioning implements Sectioning {
  List<Triple<Int, Int, String>> slideTray = list(Nil);
  Int section(ResourceManager rm,Staining st, MicroscopicAnalysis ma, Triple<Int, Int, String> block){
    List<Int> rid = list(Nil);rid = await rm!holdRes(list[set[BioTechnician, Efficiency( 2 )]]);await rm!releaseRes(rid);if ( ( length(this.slideTray) < 3 ) ){
      this.slideTray = appendright(this.slideTray, block);
    }if ( ( length(this.slideTray) == 3 ) ){
      Fut<Int> f;
      [Deadline: Duration(100)]      f = st!stain(rm,ma, this.slideTray);
      this.slideTray = Nil;
      await f?;
    }try {
    Duration d = deadline();
    Rat r = durationValue(d);
    assert r > 0;
    } catch {
    AssertionFailException => println(`The method "section" have missed the deadline.`);
    }
    return 0;
  }
  }

interface Staining {
  Int stain(ResourceManager rm,MicroscopicAnalysis ma, List<Triple<Int, Int, String>> slideTray);}

class Staining implements Staining {
  Map<Int, List<Pair<Int, String>>> specimenMap = map(Nil);
  Int stain(ResourceManager rm,MicroscopicAnalysis ma, List<Triple<Int, Int, String>> slideTray){
    List<Int> rid = list(Nil);rid = await rm!holdRes(list[set[StainingMachine, Efficiency( 5 )]]);duration(5, 5);await rm!releaseRes(rid);{
      ABS.StdLib.List<ABS.StdLib.Triple<ABS.StdLib.Int, ABS.StdLib.Int, ABS.StdLib.String>> tmp936544568 = slideTray;
      while (! isEmpty(tmp936544568)) {
        ABS.StdLib.Triple<ABS.StdLib.Int, ABS.StdLib.Int, ABS.StdLib.String> x = head(tmp936544568);
        tmp936544568 = tail(tmp936544568);
        {
          List<Pair<Int, String>> l = lookupDefault(this.specimenMap, fstT(x), list(Nil));
          this.specimenMap = put(this.specimenMap, fstT(x), appendright(l, Pair( sndT(x), trdT(x) )));
        }
      }
    }List<Fut<Int>> futList = list(Nil);{
      ABS.StdLib.List<ABS.StdLib.Pair<ABS.StdLib.Int, ABS.StdLib.List<ABS.StdLib.Pair<ABS.StdLib.Int, ABS.StdLib.String>>>> tmp2117938877 = entries(this.specimenMap);
      while (! isEmpty(tmp2117938877)) {
        ABS.StdLib.Pair<ABS.StdLib.Int, ABS.StdLib.List<ABS.StdLib.Pair<ABS.StdLib.Int, ABS.StdLib.String>>> entry = head(tmp2117938877);
        tmp2117938877 = tail(tmp2117938877);
        {
          if ( ( length(snd(entry)) == 3 ) ){
            Fut<Int> f;
            [Deadline: Duration(100)]            f = ma!analyse(rm,fst(entry), snd(entry));
            futList = appendright(futList, f);
            this.specimenMap = removeKey(this.specimenMap, fst(entry));
            await f?;
          }
        }
      }
    }while (! isEmpty(futList)) {
      Fut<Int> f = head(futList);
      futList = tail(futList);
      await f?;
    }try {
    Duration d = deadline();
    Rat r = durationValue(d);
    assert r > 0;
    } catch {
    AssertionFailException => println(`The method "stain" have missed the deadline.`);
    }
    return 0;
  }
  }

interface MicroscopicAnalysis {
  Int analyse(ResourceManager rm,Int case_id, List<Pair<Int, String>> slides);}

class MicroscopicAnalysis implements MicroscopicAnalysis {
  
  Int analyse(ResourceManager rm,Int case_id, List<Pair<Int, String>> slides){
    println(( ( "Time: " + toString(now()) ) + "" ));println(( ( toString(case_id) + "->" ) + toString(slides) ));List<Int> rid = list(Nil);rid = await rm!holdRes(list[set[Pathologist, Efficiency( 2 )]]);duration(10, 10);await rm!releaseRes(rid);try {
    Duration d = deadline();
    Rat r = durationValue(d);
    assert r > 0;
    } catch {
    AssertionFailException => println(`The method "analyse" have missed the deadline.`);
    }
    return 0;
  }
  }


{
  ResourceManager rm = new ResourceManager();
  await rm!addRes(list[set[Pathologist, Efficiency(3)], set[BioTechnician, Efficiency(5)], set[BioTechnician, Efficiency(3)], set[BioTechnician, Efficiency(10)], set[VanDriver, Efficiency(5)], set[DeliveryVan, Efficiency(1500)], set[BioTechnician, Efficiency(2)], set[BioTechnician, Efficiency(2)], set[BioTechnician, Efficiency(2)], set[BioTechnician, Efficiency(2)], set[ProcessingMachine, Efficiency(10)], set[ProcessingMachine, Efficiency(10)], set[StainingMachine, Efficiency(5)], set[StainingMachine, Efficiency(5)], set[Pathologist, Efficiency(2)], set[HeadWaiter, Efficiency(2)], set[RunnerWaiter, Efficiency(1)], set[RunnerWaiter, Efficiency(1)], set[Cook, Efficiency(5)], set[CookAssistant, Efficiency(1)], set[CookAssistant, Efficiency(1)], set[CookAssistant, Efficiency(1)], set[Cook, Efficiency(3)]]);
  Pathology p = new Pathology();
  Grossing g = new Grossing();
  Processing pr = new Processing();
  Embedding em = new Embedding();
  Sectioning sc = new Sectioning();
  Staining st = new Staining();
  MicroscopicAnalysis ma = new MicroscopicAnalysis();
  List<Fut<Int>> futList = list(Nil);
  Int i = 0;
  Int k1 = random(10);
  Int k2 = random(10);
  duration(k1, k1);
  Fut<Int> f1;
  [Deadline: Duration(150)]  f1 = p!registerCase(rm,g, pr, em, sc, st, ma);
  duration(k2, k2);
  Fut<Int> f2;
  [Deadline: Duration(150)]  f2 = p!registerCase(rm,g, pr, em, sc, st, ma);
  Fut<Int> f3;
  [Deadline: Duration(150)]  f3 = p!registerCase(rm,g, pr, em, sc, st, ma);
  await f1?;
  await f2?;
  await f3?;
}
